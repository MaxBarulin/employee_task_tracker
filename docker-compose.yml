# Описываем наши сервисы (контейнеры)
services:
  # Сервис базы данных
  db:
    image: postgres:16-alpine  # Используем официальный, легковесный образ PostgreSQL
    volumes:
      # Эта строка - ключ к сохранению данных. Она "пробрасывает" папку из контейнера
      # в специальное хранилище Docker на вашем компьютере. Данные не пропадут при перезапуске.
      - postgres_data:/var/lib/postgresql/data/
    environment:
      # Передаем в контейнер переменные из нашего .env файла
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      # Пробрасываем порт из контейнера на наш компьютер. Формат "ХОСТ:КОНТЕЙНЕР"
      # Это позволит, при желании, подключиться к БД с вашего компьютера.
      - "5432:5432"

  # Сервис нашего Django-приложения
  web:
    build: .  # Говорим Docker Compose собрать образ из Dockerfile в текущей папке
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      # Это "магия" для разработки. Мы "пробрасываем" текущую папку с кодом
      # прямо внутрь контейнера. Любое изменение в коде на вашем компьютере
      # будет МГНОВЕННО отражено в контейнере без его пересборки!
      - .:/app
    ports:
      # Пробрасываем порт 8000 из контейнера на порт 8000 нашего компьютера.
      - "8000:8000"
    env_file:
      - .env # Указываем, что нужно загрузить переменные окружения из этого файла
    environment:
      # ВАЖНО! Переопределяем хост для подключения к БД.
      # 'db' - это имя сервиса, которое мы определили выше. Docker Compose
      # сделает так, что контейнер web сможет найти контейнер db по этому имени.
      - POSTGRES_HOST=db
    depends_on:
      # Говорим, что сервис web зависит от сервиса db.
      # Это гарантирует, что контейнер с базой данных запустится РАНЬШЕ,
      # чем контейнер с приложением.
      - db

# Определяем именованный том для хранения данных PostgreSQL
volumes:
  postgres_data: